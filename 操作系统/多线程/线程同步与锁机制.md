# 线程同步与锁机制

## 什么是竞态条件（Race Condition）？如何避免？

竞态条件是指两个或多个线程同时访问共享资源，且至少有一个线程在修改资源时导致的不可预知的行为。这种情况可能导致程序出现错误或不稳定。

避免竞态条件的方式：

使用互斥锁（Mutex），使用互斥锁来保护共享资源，确保同一时刻只有一个线程可以访问该资源。
使用[原子操作](./原子操作.md)（Atomic Operations）： 在某些情况下，可以使用原子操作代替锁，以确保操作的不可分割性。

## 读写锁（Read-Write Lock）

当多个线程需要同时访问同一个文件，其中一些线程需要读文件，而另一些线程需要写文件时，为了保证文件操作的正确性和线程安全，需要使用锁来协调这些线程的操作。在这种场景下，读写锁是一个常见的解决方案。读写锁允许多个线程同时读取文件，但在有线程进行写操作时，所有其他线程（无论是读线程还是写线程）都必须等待。这种机制可以提高系统的并发性。

读写锁的工作原理

共享锁（读锁，Shared Lock）： 当线程需要读取文件时，获取共享锁。多个线程可以同时获取共享锁，从而并行执行读取操作。

独占锁（写锁，Exclusive Lock）： 当线程需要写入文件时，获取独占锁。获取独占锁时，其他线程（包括读取线程）必须等待，直到独占锁被释放。

## 死锁（Deadlock）问题

死锁是多线程编程中的一个经典问题。死锁是指两个或多个线程相互等待对方持有的资源，导致所有线程都无法继续执行。

避免死锁的方法：

1. 避免循环等待： 为所有锁资源规定一个顺序，所有线程按相同顺序获取锁。
2. 使用尝试锁（Try Lock）： 使用std::try_lock尝试获取锁，如果无法获取锁则释放已持有的锁，并稍后再尝试。
3. 使用超时锁定： 使用带超时的锁机制，避免线程无限期地等待锁。
