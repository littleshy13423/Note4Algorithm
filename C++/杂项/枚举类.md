# 枚举

## 匿名枚举（Anonymous Enum）

匿名枚举是指没有为枚举类型本身提供一个名称，但枚举成员（常量）会直接暴露在枚举声明所在的作用域中。这在 C 和 C++ 中都很常见，通常用于定义一组相关的常量，而不需要一个显式的枚举类型名。

```C++
enum {
    Red,
    Green,
    Blue
};
```

### 注意事项

作用域污染：因为匿名枚举成员直接暴露在其所在的作用域中，所以可能会与同一作用域中的其他标识符发生命名冲突。

缺乏类型安全：匿名枚举的成员是纯整数常量，不提供类型安全。如果你需要更好的类型安全性，建议使用 enum class（强类型枚举）。

## 传统枚举（Unscoped Enum）

传统枚举是一种基本的枚举类型，其成员在枚举定义所在的作用域内定义。

```c++
enum Color {
    Red,    // 默认值为 0
    Green,  // 默认值为 1
    Blue    // 默认值为 2
};
```

特征：枚举的值从 0 开始递增（除非显式指定）。枚举成员在枚举定义所在的作用域中定义。枚举类型可以隐式转换为整数类型。不同枚举类型的成员可以在同一作用域中产生名称冲突。

使用场景：当需要定义一组相关的常量，且这些常量可以用整数表示时（如状态、颜色、方向等）。可以用于替代Magic Numbers，使代码更具可读性和可维护性。

## 强类型枚举（Scoped Enum）

C++11 引入了强类型枚举，提供了更强的类型安全性和作用域控制。

```c++
enum class Color {
    Red,    // 默认值为 0
    Green,  // 默认值为 1
    Blue    // 默认值为 2
};
```

特征：枚举成员不再直接暴露在所在的作用域中，必须通过 Color::Red 的方式来访问。
强类型枚举不能隐式转换为整数类型，这增强了类型安全性。可以显式指定枚举的底层类型（如 int、unsigned int）。

使用场景：当需要枚举成员具有作用域控制时（防止命名冲突）。当需要类型安全性更强时（防止无意的整数转换）。

## 枚举的高级用法

### 枚举与位运算

使用枚举类型来定义一组标志位非常常见。通过位运算，可以方便地对标志位进行组合、检查和清除。

```c++
enum Permission {
    Read    = 0x01,  // 0001
    Write   = 0x02,  // 0010
    Execute = 0x04   // 0100
};

int permissions = Permission::Read | Permission::Write;

// 检查权限
if (permissions & Permission::Read) {
    // has read permission
}
```